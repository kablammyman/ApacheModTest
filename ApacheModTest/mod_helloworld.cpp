/*
this file cant be a .cpp file.
it will copmpile, but apache wont be abnle to load it

if you wrap c stuff around c++  like i did here, then you can load it?

C:\wamp\bin\apache\ApacheX.X.XX\modules
then left click wamp icon > apache > httpd.conf
find the module section
add this line to the end of the section
LoadModule MODULENAME modules/MODULENAME.so
So you'll use
LoadModule imap_module modules/mod_imap.so

*  mod_helloworld.c -- Apache sample helloworld module
*  [Autogenerated via ``apxs -n helloworld -g'']
*
*  To play with this sample module first compile it into a
*  DSO file and install it into Apache's modules directory
*  by running:
*
*    $ apxs -c -i mod_helloworld.c
*
*  Then activate it in Apache's httpd.conf file for instance
*  for the URL /helloworld in as follows:
*
*    # httpd.conf
*    LoadModule helloworld_module modules/mod_helloworld.so


*    <Location /hello>   //<- this tells apache what the url is for the modul
*      SetHandler helloworld  //<- this is the module to run when we hit that url
*    </Location>
*
*  Then after restarting Apache via
*
*    $ apachectl restart
*
*  you immediately can request the URL /helloworld and watch for the
*  output of this module. This can be achieved for instance via:
*
*    $ lynx -mime_header http://localhost/hello
*/

#include "mod_helloworld.h"
#include "cppTest.h"
#include "Parcel.h"
#include "DatabaseController.h"

// request handler example

// request_rec Struct Reference
// http://ci.apache.org/projects/httpd/trunk/doxygen/structrequest__rec.html

//https://github.com/seratch/apache-module-samples/blob/master/helloworld/mod_helloworld.c
/*
	text/enriched
	text/html
	text/plain
	text/rfc822-headers
	text/richtext
	text/sgml
	*/
EXTERN_C_FUNC
static void DoHTMLOutput(request_rec *req)
{
	char ret[1000];
	strcpy(ret, "<!DOCTYPE html>\n<html>\n<head>\n</head>\n<body>\n");
	strcat(ret, "<h1>Data stuff</h1>\n");

	char pathInfo[100];
	sprintf(pathInfo, "path info: %s<br>",req->path_info);
	strcat(ret, pathInfo) ;

	char args[100];
	sprintf(args, "args: %s<br>", req->args);
	strcat(ret, args);
	
	char method[100];
	sprintf(method, "method: %s<br>", req->method);
	strcat(ret, method);

	strcat(ret, "</body>\n</html>\n");
	ap_rputs(ret, req);
	req->content_type = "text/html;charset=UTF-8";
}

static void DoJsonOutput(request_rec *req)
{
	char ret[1000];
	strcpy(ret, "{\n");
	strcat(ret, "\"title\": \"Hello world!\",\n");

	char pathInfo[100];
	sprintf(pathInfo, "\"path info\": \"%s\",\n", req->path_info);
	strcat(ret, pathInfo);

	char args[100];
	sprintf(args, "\"args\": \"%s\",\n", req->args);
	strcat(ret, args);
	
	TestClass tc;
	std::string temp = "yo";
		temp += " mama";
	char method[100];
	sprintf(method, "method: \"%s\",\n\"add\":%d,\n\"string\":\"%s\"", req->method, tc.Add(2,7),temp.c_str());
	strcat(ret, method);
	
	strcat(ret, "}\n");
	ap_rputs(ret, req);


	req->content_type = "application/json;charset=UTF-8";
}

static void ParcelTest(request_rec *req)
{
	DatabaseController dbControllerEureka;
	DatabaseController dbControllerMain;
	dbControllerEureka.OpenDB("E:\\documents\\land investing\\parcels\\eureka county NV\\EurekaParcels.db");
	dbControllerMain.OpenDB("E:\\documents\\land investing\\scripts\\LandInvestments.db");

	ParcelTable *parcelTable = new ParcelTable(&dbControllerMain);
	ParcelTable::Parcel * parcel = parcelTable->GetParcelInfo(2424);
	char ret[1000];
	strcpy(ret, "{\n");
	
	char args[20];
	sprintf(args, "\"apn\": \"%s\",\n", parcel->APN);
	strcat(ret, args);

	char pathInfo[30];
	sprintf(pathInfo, "\"county\": \"%s\",\n", parcel->county);
	strcat(ret, pathInfo);

	strcat(ret, "}\n");
	ap_rputs(ret, req);


	req->content_type = "application/json;charset=UTF-8";
	

}
EXTERN_C_FUNC
static int helloworld_handler(request_rec *req)
{
	//the handler name
	if (strcmp(req->handler, "helloworld")) 
	{
		return DECLINED;
	}

	//The HEAD method is identical to GET except that the server MUST NOT return a message - body in the response.
	if (req->header_only) 
	{
		
	}
//	else if (req->method == "GET")
	if(req->method_number == M_GET)
	{
		if(strcmp(req->path_info, "/html")==0)
			DoHTMLOutput(req);
		else if (strcmp(req->path_info , "/json")==0)
			ParcelTest(req);
		else 
			DoJsonOutput(req);
	}
	else
	{
		ap_rputs("i dunno", req);
		req->content_type = "text/plain;charset=UTF-8";
	}
	// ap_table_set is too old API
	apr_table_set(req->headers_out, "X-Content-Type-Options", "nosniff");

	return OK;
}

EXTERN_C_FUNC
static void helloworld_register_hooks(apr_pool_t *p)
{
	printf("\n ** helloworld_register_hooks  **\n\n");
	ap_hook_handler(helloworld_handler, NULL, NULL, APR_HOOK_MIDDLE);
}

EXTERN_C_BLOCK_BEGIN
/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA helloworld_module = { //is this the name of the module?
	STANDARD20_MODULE_STUFF,
	NULL, /* create per-dir    config structures */
	NULL, /* merge  per-dir    config structures */
	NULL, /* create per-server config structures */
	NULL, /* merge  per-server config structures */
	NULL, /* table of config file commands       */
	helloworld_register_hooks  /* register hooks */
};
EXTERN_C_BLOCK_END